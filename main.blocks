<xml xmlns="https://developers.google.com/blockly/xml"><block type="pxt-on-start" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace MPU6050 {" line1="" line2="" line3="    export enum REGISTER {" line4="        POWERON = 0x6b," line5="        ACCEL_X = 0x3b," line6="        ACCEL_Y = 0x3d," line7="        ACCEL_Z = 0x3f," line8="        TEMPATURE = 0x41," line9="        GYRO_X = 0x43," line10="        GYRO_Y = 0x45," line11="        GYRO_Z = 0x47" line12="    }" line13="" line14="    export enum AXIS {" line15="        X = 1," line16="        Y = 2," line17="        Z = 3" line18="    }" line19="" line20="" line21="    export enum MPU6050_I2C_ADDRESS {" line22="        ADDR_0x68 = 0x68," line23="        ADDR_0x69 = 0x69" line24="    }" line25="" line26="    let initialized = false" line27="    let MPU6050_ADDRESS = MPU6050_I2C_ADDRESS.ADDR_0x68" line28="" line29="" line30="    function i2cWrite(addr: number, reg: number, value: number): void {" line31="        let buf = pins.createBuffer(2);" line32="        buf[0] = reg;" line33="        buf[1] = value;" line34="        pins.i2cWriteBuffer(addr, buf);" line35="    }" line36="" line37="    function i2cRead(addr: number, reg: number): number {" line38="        pins.i2cWriteNumber(addr, reg, NumberFormat.UInt8BE);" line39="        let val = pins.i2cReadNumber(addr, NumberFormat.UInt8BE);" line40="        return val;" line41="    }" line42="" line43="    function checkAddress(addr: MPU6050_I2C_ADDRESS): boolean {" line44="        switch (addr) {" line45="            case MPU6050_I2C_ADDRESS.ADDR_0x68:" line46="                return true" line47="            case MPU6050_I2C_ADDRESS.ADDR_0x69:" line48="                return true" line49="            default:" line50="                return false" line51="        }" line52="        return false" line53="    }" line54="" line55="    /**" line56="&#9; * 初始化MPU6050" line57="&#9; * @param addr [0-1] choose address; eg: MPU6050.MPU6050_I2C_ADDRESS.ADDR_0x68" line58="&#9;*/" line59="    //% blockId=&quot;MPU6050_initMPU6050&quot;" line60="    //% block=&quot;initialize MPU6050 device address %addr&quot;" line61="    //% weight=85" line62="    export function initMPU6050(addr: MPU6050_I2C_ADDRESS) {" line63="        if (checkAddress(addr)) {" line64="            i2cWrite(MPU6050_ADDRESS, REGISTER.POWERON, 0)" line65="        }" line66="    }" line67="" line68="    /**" line69="&#9; * 复位MPU6050" line70="&#9; * @param addr [0-1] choose address; eg: MPU6050.MPU6050_I2C_ADDRESS.ADDR_0x68" line71="&#9;*/" line72="    //% blockId=&quot;MPU6050_resetMPU6050&quot;" line73="    //% block=&quot;initialize MPU6050 device address %addr&quot;" line74="    //% weight=85" line75="    export function resetMPU6050(addr: MPU6050_I2C_ADDRESS) {" line76="        if (checkAddress(addr)) {" line77="            i2cWrite(MPU6050_ADDRESS, REGISTER.POWERON, 1)" line78="        }" line79="    }" line80="" line81="" line82="    /**" line83="&#9; *Read byte from MPU6050 register" line84="&#9; * @param reg  register of MPU6050; eg: 0, 15, 23" line85="&#9;*/" line86="    function readByte(addr: MPU6050_I2C_ADDRESS, reg: REGISTER): number {" line87="        let val2 = i2cRead(addr, reg);" line88="        return val2;" line89="    }" line90="" line91="    /**" line92="&#9; *Read data from MPU6050 register" line93="&#9; * @param reg  register of MPU6050; eg: 0, 15, 23" line94="&#9;*/" line95="    function readWord(addr: MPU6050.MPU6050_I2C_ADDRESS, reg: REGISTER): number {" line96="        let valh = i2cRead(addr, reg);" line97="        let vall = i2cRead(addr, reg + 1);" line98="        let val3 = (valh &lt;&lt; 8) + vall" line99="        return val3" line100="    }" line101="" line102="    /**" line103="&#9; *Read data from MPU6050 register" line104="&#9; * @param reg  register of MPU6050; eg: 0, 15, 23" line105="&#9;*/" line106="    function readWord2C(addr: MPU6050_I2C_ADDRESS, reg: REGISTER): number {" line107="        let val4 = readWord(addr, reg)" line108="        if (val4 &gt; 0x8000) {" line109="            return -((65535 - val4) + 1)" line110="        } else {" line111="            return val4" line112="        }" line113="    }" line114="" line115="" line116="    /**" line117="    *  读取温度" line118="   */" line119="    //% blockId=MPU6050_readTempature " line120="    //% block=&quot;read tempature for device %addr&quot;" line121="    //% weight=75" line122="    export function readTempature(addr: MPU6050_I2C_ADDRESS): number {" line123="        if (checkAddress(addr)) {" line124="            let value = readWord2C(addr, REGISTER.TEMPATURE)" line125="            return 36.53 + value / 340;" line126="        } else {" line127="            return 0" line128="        }" line129="    }" line130="" line131="    /**" line132="&#9; * 获取线性加速度" line133="&#9;*/" line134="    //% blockId=MPU6050_get_accel" line135="    //% block=&quot;get device |%addr| axis |%axis| accel data&quot;" line136="    //% weight=75" line137="    export function getAccel(addr: MPU6050_I2C_ADDRESS, axis: AXIS): number {" line138="        if (checkAddress(addr)) {" line139="            switch (axis) {" line140="                case AXIS.X:" line141="                    return readWord2C(addr, REGISTER.ACCEL_X)" line142="                case AXIS.Y:" line143="                    return readWord2C(addr, REGISTER.ACCEL_Y)" line144="                case AXIS.Z:" line145="                    return readWord2C(addr, REGISTER.ACCEL_Z)" line146="                default:" line147="                    return 0" line148="            }" line149="        }" line150="        return 0" line151="    }" line152="" line153="    /**" line154="&#9; * 获取角速度" line155="&#9;*/" line156="    //% blockId=MPU6050_get_gyro" line157="    //% block=&quot;get device |%addr| axis |%axis| gyro data&quot;" line158="    //% weight=75" line159="    export function getGyro(addr: MPU6050_I2C_ADDRESS, axis: AXIS): number {" line160="        if (checkAddress(addr)) {" line161="            switch (axis) {" line162="                case AXIS.X:" line163="                    return readWord2C(addr, REGISTER.GYRO_X)" line164="                case AXIS.Y:" line165="                    return readWord2C(addr, REGISTER.GYRO_Y)" line166="                case AXIS.Z:" line167="                    return readWord2C(addr, REGISTER.GYRO_Z)" line168="                default:" line169="                    return 0" line170="            }" line171="        }" line172="        return 0" line173="    }" line174="" line175="}" numlines="176"></mutation></block></statement></block></xml>